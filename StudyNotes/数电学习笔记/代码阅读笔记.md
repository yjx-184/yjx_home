- [阅读verilator编译出的C++代码（例：双控开关）](#阅读verilator编译出的c代码例双控开关)
  - [Vtop.h](#vtoph)
    - [1.保护符号](#1保护符号)
    - [2.包含Verilator库](#2包含verilator库)
    - [3.类前向声明](#3类前向声明)
    - [4.定义 Vtop 类(Verilated 模型的主要接口)](#4定义-vtop-类verilated-模型的主要接口)
    - [5.符号表 (Vtop\_\_Syms)](#5符号表-vtop__syms)
    - [6.端口声明](#6端口声明)
    - [7.根实例指针](#7根实例指针)
    - [8.构造函数与析构函数](#8构造函数与析构函数)
    - [9.评估和仿真方法](#9评估和仿真方法)
    - [10.事件处理方法](#10事件处理方法)
    - [11.模型信息方法](#11模型信息方法)
      - [源代码](#源代码)



# 阅读verilator编译出的C++代码（例：双控开关）
## Vtop.h
### 1.保护符号
>>防止头文件在编译过程中被多次包含，确保只包含一次。  
>>>>#ifndef VERILATED_VTOP_H_
>>>>#define VERILATED_VTOP_H_

### 2.包含Verilator库
>>包含 Verilator 提供的头文件，为 Verilator 模型的构造提供基础支持。
>>>>#include "verilated.h"

### 3.类前向声明
>>前向声明符号表类 (Vtop__Syms) 和根实例类 (Vtop___024root)，这些是 Verilator 生成的内部类，用于保存模型状态和实例指针。
>>>>class Vtop__Syms;
>>>>class Vtop___024root;

### 4.定义 Vtop 类(Verilated 模型的主要接口)
>>Vtop 类继承自 VerilatedModel，这是 Verilator 自动生成的模型基类。
>>Vtop 类是用于与仿真模型交互的接口类，内部封装了 Verilator 模型的状态和行为。
>>该类的对象会通过构造函数进行初始化，随后通过调用 eval() 等方法进行模型评估。

### 5.符号表 (Vtop__Syms)
>>vlSymsp 是一个指向符号表的指针，保存了模型的完整状态，所有的仿真状态和信号都由它管理。
>>>>Vtop__Syms* const vlSymsp;

### 6.端口声明
VL_IN8(&a,0,0);
VL_IN8(&b,0,0);
VL_OUT8(&f,0,0);

### 7.根实例指针
Vtop___024root* const rootp;

### 8.构造函数与析构函数
>>构造函数用于初始化模型实例，允许用户传入上下文 (contextp) 和模型名称 (name) 。
>>析构函数用于销毁模型实例。
>>>>explicit Vtop(VerilatedContext* contextp, const char* name = "TOP");
>>>>virtual ~Vtop();

### 9.评估和仿真方法
>>eval() 和 eval_step() 是核心的模型评估方法，评估输入信号并更新模型状态。
>>final() 在仿真结束时调用，执行所有的收尾操作。
>>>>void eval();
>>>>void eval_step();
>>>>void final();

### 10.事件处理方法
bool eventsPending();
uint64_t nextTimeSlot();

### 11.模型信息方法
>>这些方法提供与模型有关的信息，如模型的名称、层次结构名称、模型名以及使用的线程数。
>>>>const char* name() const;
>>>>const char* hierName() const override final;
>>>>const char* modelName() const override final;
>>>>unsigned threads() const override final;
#### 源代码
```c
// Verilated -*- C++ -*-
// 说明：Verilator 输出：主模型头文件
//
// 该头文件应被所有实例化设计的源文件包含。
// 这里的类随后会被构造以实例化设计。
// 参见 Verilator 手册中的示例。

#ifndef VERILATED_VTOP_H_
#define VERILATED_VTOP_H_  // guard

#include "verilated.h"

class Vtop__Syms;
class Vtop___024root;

// 此类是 Verilated 模型的主要接口
class Vtop VL_NOT_FINAL : public VerilatedModel {
  private:
    // 符号表保存完整的模型状态（由此类拥有）
    Vtop__Syms* const vlSymsp;

  public:

    // 端口
    // 应用代码写入和读取这些信号以将新值传播到 Verilated 模型内/外。
    VL_IN8(&a,0,0);
    VL_IN8(&b,0,0);
    VL_OUT8(&f,0,0);

    // 单元
    // 公开访问 /* verilator public */ 项目。
    // 否则，应用代码可以将这些内容视为内部项。

    // 根实例指针，允许访问模型内部，
    // 包括内联的 /* verilator public_flat_* */ 项目。
    Vtop___024root* const rootp;

    // 构造函数
    /// 构造模型；由应用代码调用
    /// 如果 contextp 为 null，则模型将使用默认的全局上下文
    /// 如果 name 为空字符串 ""，则会创建一个
    /// 在 DPI 范围名称中不可见的单模型包装器。
    explicit Vtop(VerilatedContext* contextp, const char* name = "TOP");
    explicit Vtop(const char* name = "TOP");
    /// 销毁模型；由应用代码调用（通常隐式调用）
    virtual ~Vtop();
  private:
    VL_UNCOPYABLE(Vtop);  ///< 不允许复制

  public:
    // API 方法
    /// 评估模型。输入改变时应用程序必须调用此函数。
    void eval() { eval_step(); }
    /// 当每个时间步调用多个单元/模型时进行评估。
    void eval_step();
    /// 在一个时间步结束时进行评估以进行跟踪，当使用 eval_step() 时调用。
    /// 应用程序必须在所有 eval() 调用后且在时间改变之前调用。
    void eval_end_step() {}
    /// 仿真完成，执行最终块。应用程序必须在仿真完成时调用此函数。
    void final();
    /// 是否有计划处理的事件？
    bool eventsPending();
    /// 返回下一个时间槽的时间。如果 !eventsPending() 则中止。
    uint64_t nextTimeSlot();
    /// 检索此模型实例的名称（与构造函数传递的名称相同）。
    const char* name() const;

    // 从 VerilatedModel 抽象的方法

    const char* hierName() const override final;
    const char* modelName() const override final;
    unsigned threads() const override final;
} VL_ATTR_ALIGNED(VL_CACHE_LINE_BYTES);

#endif  // guard
```
