- [1.数据结构](#1数据结构)
  - [集合](#集合)
    - [不可变集合immutable](#不可变集合immutable)
      - [List](#list)
      - [Vector](#vector)
      - [Set](#set)
      - [Map](#map)
    - [可变集合mutable](#可变集合mutable)
      - [ArrayBuffer](#arraybuffer)
      - [HashSet](#hashset)
      - [HashMap](#hashmap)
    - [Seq序列](#seq序列)
    - [集合操作](#集合操作)
  - [Tuple元组](#tuple元组)
  - [Option](#option)
  - [Iterator](#iterator)
  - [Queue 队列](#queue-队列)
  - [Stack 栈](#stack-栈)
- [2.控制结构](#2控制结构)
  - [条件语句if-else](#条件语句if-else)
  - [模式匹配](#模式匹配)
  - [循环结构](#循环结构)
    - [for循环](#for循环)
      - [传统的for循环](#传统的for循环)
      - [区间for循环](#区间for循环)
      - [带有条件的 for 循环](#带有条件的-for-循环)
      - [for 推导式： 可以使用 for 生成新的集合。](#for-推导式-可以使用-for-生成新的集合)
    - [while 循环](#while-循环)
    - [do-while 循环](#do-while-循环)
  - [异常处理try-catch-finally](#异常处理try-catch-finally)
- [3.数据类型](#3数据类型)
  - [基本类型](#基本类型)
  - [集合类型](#集合类型)
  - [特殊类型](#特殊类型)
- [3.类](#3类)
  - [特质](#特质)
  - [抽象类](#抽象类)
  - [样例类](#样例类)
  - [单例对象](#单例对象)
- [4.隐式转换](#4隐式转换)


# 1.数据结构
## 集合
### 不可变集合immutable
scala默认不可变集合。不可变集合是不允许修改的，每次修改都会返回一个新的集合。

#### List
不可变的链表。最常用的操作是head和tail。前者返回列表第一个元素，后者返回去除第一个元素的剩下部分。  
创建一个新的链表：  
```
val list1 = List(1,2,3)
```  

#### Vector
不可变的随机访问序列，比List更高效地支持索引访问，底层实现是通过树的结构来优化性能。  
创建一个新的随机访问序列：  
```
val vector1 = Vector(1,2,3)
```  

#### Set
不可变的集合，保证元素唯一，支持高效的查找，添加和删除操作。  
创建一个新的集合：  
```
val set1 = Set(1,2,3)
```  

#### Map
不可变的键值对集合，键是唯一的，可以高效地查找，更新或删除值。  
创建一个新的键值对集合：  
```
val map1 = Map("a" -> 1, "b" -> 2, "c" -> 3)
```  
***  
### 可变集合mutable
引用可变集合需要导入包scala.collection.mutable。都有可变版本。

#### ArrayBuffer
可变的动态数组，能够在不重新分配内存的情况下动态地增加或减少元素。  
创建一个动态数组：  

#### HashSet
可变的哈希集合，提供高效的元素添加、删除和查找。  

#### HashMap
可变的哈希表，提供高效的键值对插入、删除和查找。  
***  
### Seq序列
序列是可按顺序访问元素的集合。可以包含重复元素。Lsit和Vector都是Seq的子类型。  
***  
### 集合操作
map：对集合中的每个元素应用一个函数。  
filter：过滤集合中的元素。  
fold：使用一个初始值和一个二元操作来合并集合中的元素。  
reduce：类似于fold，但是没有初始值。  
flatMap：类似于map，但是对每个元素返回一个集合，并将结果扁平化。  

## Tuple元组
元组是一个固定大小的，包含多个不同类型的元素的集合。可以存储任意数量的元素，元素类型不必相同。  
创建一个元组：  
```
val tuple = (1, "hello", true)
```  

## Option
Option是一个表示可能存在或不存在的值的类型。它可以是Some或None。  
Some(value)：表示存在一个值。  
None：表示没有值。  
Option常用于避免空指针异常。  

## Iterator
用于遍历集合的对象，实现了按需遍历的懒计算机制，可以一次返回一个元素。常用于大数据集的遍历。  
示例：  
```
val iterator = List(1,2,3).iterator
```  

## Queue 队列
先进先出的数据结构。  

## Stack 栈
后进先出的数据结构。  

# 2.控制结构
## 条件语句if-else
if语句用于根据条件值性不同的代码快。scala中的if语句不仅是控制流语句，还是表达式，这意味着它会返回一个值。  

## 模式匹配
scala的模式匹配类似于switch语句，但功能更强大，支持匹配类型、值、结构等。  
基本用法：  
```
val x = 2
x match {
    case 1 => println("One")
    case 2 => println("Two")
    case _ => println("Other")
}
```  
复杂的模式匹配：  
```
val person = ("abc", 24)
person match {
    case (name, age) if age > 18 =>println(s"$name是成年人")
    case (name, age) =>println(s"$name 是未成年人.")
}
```  
## 循环结构
### for循环
Scala 提供了功能强大的 for 循环，不仅支持传统的迭代器，还可以实现生成新集合的功能。

#### 传统的for循环
```
for (i <- 1 to 5) {
  println(i)  // 输出 1 到 5
}
```  

#### 区间for循环
```
for (i <- 1 until 5) {
  println(i)  // 输出 1 到 4
}
```  

#### 带有条件的 for 循环
```
for (i <- 1 to 10 if i % 2 == 0) {
  println(i)  // 输出偶数：2 4 6 8 10
}
```  

#### for 推导式： 可以使用 for 生成新的集合。
```
val evenNumbers = for (i <- 1 to 10 if i % 2 == 0) yield i
println(evenNumbers)  // 输出 Vector(2, 4, 6, 8, 10)
```  
### while 循环
while 循环会在条件为 true 时重复执行。

### do-while 循环
do-while 循环至少会执行一次，然后在条件为 true 时继续执行。

## 异常处理try-catch-finally
Scala 提供了异常处理机制，类似于 Java，但支持 Try、Success、Failure 类型的表达式，使得函数式编程更加简洁。

# 3.数据类型
在scala中，所有数据类型都是对象。  
## 基本类型
Byte:8位有符号整数，数值范围-128到127  
Short:16位有符号整数，数值范围 -32768 到 32767  
Int:32位有符号整数，数值范围 -2147483648 到 2147483647  
Long:64位有符号整数，数值范围-9223372036854775808 到 9223372036854775807  
Float:32位IEEE 754单精度浮点数  
Double:64位IEEE 754双精度浮点数  
Char:16位无符号Unicode字符，数值范围为 U+0000 到 U+FFFF  
String:字符串类型，表示字符序列  
Boolean:布尔类型，值为 true 或 false  

## 集合类型
List:不可变链表  
Set:不可变集合  
Map:不可变键值对集合  
Array:可变数组  
Tuple:可包含不同类型元素的不可变容器  
Option:代表有可能含有值或为空的容器  
Either:表示两种可能的值类型之一  
Try:处理操作结果可能成功或失败的容器  

## 特殊类型
Unit:表示无值，相当于Java中的 void  
Null:单例对象，表示所有引用类型的空值  
Nothing:表示无返回值类型，是所有类型的子类型  
Any:所有类型的超类型  
AnyRef:所有引用类型的超类型，等价于Java中的 Object  

# 3.类
一个最简单类的定义就是关键字class，类首字母应该大写。同时，类支持以下功能： 主构造函数 和辅助构造函数 。字段和方法。伴生对象提供工厂方法。继承和多态。抽象类和特质。封闭类，限制继承范围。默认参数，简化方法和构造函数调用。
## 特质
特质 (Traits) 用于在类 (Class)之间共享程序接口 (Interface)和字段 (Fields)。特质不能被实例化。想要定义一个特质要使用关键字trait 。想要使用特质要使用关键字extends。然后使用关键字override来实现trait里面的任何抽象成员。  

## 抽象类
抽象类是一种不能被直接实例化的类。它用于定义一个基本模板，子类必须实现其中的抽象方法。抽象类可以包含抽象方法（没有实现的方法）和非抽象方法（已经实现的方法），这使得它既能提供方法的框架，又能提供默认的实现。想要定义一个抽象类要使用关键字abstract class。通常用于定义通用行为和属性，具体实现则需要子类完成。  

## 样例类
样例类case class是一种特殊类型的类。用于简化类的创建和使用。且样例类的字段默认是不可变的。特别适合用于模式匹配。Scala 会自动为样例类提供 unapply 方法，从而可以在模式匹配中提取类的字段。想要定义一个样例类要使用关键字case class。这种定义方式会自动为 Person 类生成构造方法、toString、equals、hashCode 等方法。

## 单例对象
单例对象是一种特殊的类。通过关键字object定义。它在整个应用程序生命周期内只有一个实例。  
用途：  
作为类的伴生对象：与类同名，可以互相访问四有成员，同时也可以提供类的静态方法。  
作为静态方法容器：通过单例对象来实现类似于静态方法。  
实现单例模式：通过单例对象可以确保类只有一个实例，适用于需要全局唯一实例的场景。  
作为工厂：单例对象常用于工厂模式，返回某个类的实例。  

# 4.隐式转换
隐式转换（Implicit Conversion）是一种强大的机制，它允许编译器在某些情况下自动地将一种类型转换为另一种类型，而不需要显式调用转换方法。隐式转换通过关键字implicit来实现。隐式方法通常定义在 伴生对象 或 隐式对象 中。  
通常用于以下几种情况：  
1.在类型部匹配的情况下，编译器会查找何时的隐式转换来解决。2.使用隐式函数或隐身方法，将一种类型转换为另一种类型。