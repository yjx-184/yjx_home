$date
	Fri Dec 13 14:18:18 2024
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module tb_ALU $end
$var wire 1 ! Zero $end
$var wire 1 " Less $end
$var wire 32 # ALUout [31:0] $end
$var reg 1 $ ALUAsrc $end
$var reg 2 % ALUBsrc [1:0] $end
$var reg 4 & ALUctr [3:0] $end
$var reg 1 ' CLK $end
$var reg 32 ( imm [31:0] $end
$var reg 32 ) pc [31:0] $end
$var reg 32 * rs1 [31:0] $end
$var reg 32 + rs2 [31:0] $end
$scope module u_ALU $end
$var wire 1 $ ALUAsrc $end
$var wire 2 , ALUBsrc [1:0] $end
$var wire 4 - ALUctr [3:0] $end
$var wire 32 . imm [31:0] $end
$var wire 32 / pc [31:0] $end
$var wire 32 0 rs1 [31:0] $end
$var wire 32 1 rs2 [31:0] $end
$var wire 1 2 u_s $end
$var wire 32 3 sit [31:0] $end
$var wire 32 4 shift [31:0] $end
$var wire 32 5 result [31:0] $end
$var wire 1 6 overflow $end
$var wire 1 7 l_r $end
$var wire 32 8 i_XOR [31:0] $end
$var wire 32 9 i_OR [31:0] $end
$var wire 32 : i_AND [31:0] $end
$var wire 1 ; carry $end
$var wire 3 < actr [2:0] $end
$var wire 1 = a_l $end
$var wire 1 ! Zero $end
$var wire 1 " Less $end
$var wire 1 > Cin $end
$var wire 32 ? B [31:0] $end
$var wire 32 @ A [31:0] $end
$var reg 32 A ALUout [31:0] $end
$scope module u_ALU_select $end
$var wire 1 $ ALUAsrc $end
$var wire 2 B ALUBsrc [1:0] $end
$var wire 32 C imm [31:0] $end
$var wire 32 D pc [31:0] $end
$var wire 32 E rs1 [31:0] $end
$var wire 32 F rs2 [31:0] $end
$var reg 32 G ALU_A [31:0] $end
$var reg 32 H ALU_B [31:0] $end
$upscope $end
$scope module u_a_control $end
$var wire 4 I ALUctr [3:0] $end
$var reg 1 > Cin $end
$var reg 1 = a_l $end
$var reg 3 J actr [2:0] $end
$var reg 1 7 l_r $end
$var reg 1 2 u_s $end
$upscope $end
$scope module u_adder $end
$var wire 32 K A1 [31:0] $end
$var wire 32 L B1 [31:0] $end
$var wire 1 > Cin $end
$var wire 1 6 Overflow $end
$var wire 1 ! Zero $end
$var wire 32 M t_add_cin [31:0] $end
$var wire 32 N Result [31:0] $end
$var wire 1 ; Carry $end
$upscope $end
$scope module u_al $end
$var wire 1 ; Carry $end
$var wire 1 > Cin $end
$var wire 1 6 Overflow $end
$var wire 32 O i_Result [31:0] $end
$var wire 1 2 u_s $end
$var reg 1 " Less $end
$var reg 32 P o_Result [31:0] $end
$var reg 1 Q r0 $end
$var reg 1 R r1 $end
$upscope $end
$scope module u_bs $end
$var wire 32 S B1 [31:0] $end
$var wire 32 T Din [31:0] $end
$var wire 1 = a_l $end
$var wire 1 7 l_r $end
$var wire 32 U shift [31:0] $end
$var wire 5 V Shamt [4:0] $end
$upscope $end
$scope module u_l_and $end
$var wire 32 W i_a [31:0] $end
$var wire 32 X i_b [31:0] $end
$var wire 32 Y o_result [31:0] $end
$upscope $end
$scope module u_l_or $end
$var wire 32 Z i_a [31:0] $end
$var wire 32 [ i_b [31:0] $end
$var wire 32 \ o_result [31:0] $end
$upscope $end
$scope module u_l_xor $end
$var wire 32 ] i_a [31:0] $end
$var wire 32 ^ i_b [31:0] $end
$var wire 32 _ o_result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b110000 _
b100000 ^
b10000 ]
b110000 \
b100000 [
b10000 Z
b0 Y
b100000 X
b10000 W
b0 V
b10000 U
b10000 T
b100000 S
0R
0Q
b110000 P
b110000 O
b110000 N
b100000 M
b100000 L
b10000 K
b0 J
b0 I
b100000 H
b10000 G
b100000 F
b10000 E
b0 D
b0 C
b0 B
b110000 A
b10000 @
b100000 ?
0>
0=
b0 <
0;
b0 :
b110000 9
b110000 8
07
06
b110000 5
b10000 4
b110000 3
02
b100000 1
b10000 0
b0 /
b0 .
b0 -
b0 ,
b100000 +
b10000 *
b0 )
b0 (
0'
b0 &
b0 %
0$
b110000 #
0"
0!
$end
#1000
1'
#2000
1;
b11110000 3
b11110000 P
0R
0Q
b11111111111111111111111111110001 M
b1111 V
b11110000 #
b11110000 A
b11110000 5
b11110000 N
b11110000 O
b11111111000000000000000 4
b11111111000000000000000 U
b1111 :
b1111 Y
b11111111 9
b11111111 \
b11110000 8
b11110000 _
1>
b1111 ?
b1111 H
b1111 L
b1111 S
b1111 X
b1111 [
b1111 ^
b11111111 @
b11111111 G
b11111111 K
b11111111 T
b11111111 W
b11111111 Z
b11111111 ]
0'
b1000 &
b1000 -
b1000 I
b1111 +
b1111 1
b1111 F
b11111111 *
b11111111 0
b11111111 E
#3000
1'
#4000
1!
0Q
06
b0 #
b0 A
b1 M
b0 3
b0 P
0"
1R
b1 V
b0 5
b0 N
b0 O
b11111111111111111111111111111110 4
b11111111111111111111111111111110 U
b1 :
b1 Y
b11111111111111111111111111111111 9
b11111111111111111111111111111111 \
b11111111111111111111111111111110 8
b11111111111111111111111111111110 _
b10 <
b10 J
0>
b1 ?
b1 H
b1 L
b1 S
b1 X
b1 [
b1 ^
b11111111111111111111111111111111 @
b11111111111111111111111111111111 G
b11111111111111111111111111111111 K
b11111111111111111111111111111111 T
b11111111111111111111111111111111 W
b11111111111111111111111111111111 Z
b11111111111111111111111111111111 ]
0'
b10 &
b10 -
b10 I
b1 +
b1 1
b1 F
b11111111111111111111111111111111 *
b11111111111111111111111111111111 0
b11111111111111111111111111111111 E
#5000
1'
#6000
1Q
0!
b111101111 3
b111101111 P
0R
b11110000 M
b10000 V
b11110000 #
b11110000 A
b111101111 5
b111101111 N
b111101111 O
0;
b111111110000000000000000 4
b111111110000000000000000 U
b11110000 :
b11110000 Y
b11111111 9
b11111111 \
b1111 8
b1111 _
b111 <
b111 J
b11110000 ?
b11110000 H
b11110000 L
b11110000 S
b11110000 X
b11110000 [
b11110000 ^
b11111111 @
b11111111 G
b11111111 K
b11111111 T
b11111111 W
b11111111 Z
b11111111 ]
0'
b111 &
b111 -
b111 I
b11110000 +
b11110000 1
b11110000 F
b11111111 *
b11111111 0
b11111111 E
#7000
1'
#8000
0'
